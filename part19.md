## ビジネスメタをオントロジーで書く - Part 19

### R2RML込みの視覚化に意味はあるか？

前回はSQLテーブルをオントロジーに繋げるフォーマルな手段のひとつとしてR2RMLにチャレンジした。最終結果の図を以下に再掲する。

![p18fig3](/media/p18fig3.png)


改めてしげしげと観察するとふたつの疑問が生じる。ひとつは、「真ん中の`b0`から下に伸びている2本の線はどこから湧いてきたのか」である。

元々のturtleにも、Fusekiのトリプルにもこんな線は存在しない。GenAIとの議論を経た結論は、「どうやらGraph Explorerの描画アルゴリズムになんらかの導出ロジックがあるっぽい」ということである。`b0`の親 (<#OrderMapping>) は`b1` / `b2` と共通なので、それらと同じ繋がり (`rr:predicate` / `rr:class`) を「自動反復」している、という訳だ。

これはおそらくR2RMLに限った話ではなく、RDFの視覚化アプリとして「売りになる」機能なのだろう。明示的なトリプルだけでなく、そこから暗黙的に導出 (derive) された関係も自動で表示しますよ、というわけだ。「親切設計」なのかも知れないが、(筆者のような) よく知らない素人は混乱するし、プロには余計なお節介、と取られるかもしれない。Graph Explorerを使う上での要注意点のひとつであろう。

もうひとつの疑問は、「顧客のマッピングがない」ことだ。この事象の背景は単純で、コードは毎度の如くGenAIにお題を出して書いてもらっている訳だが、お題の出し方が悪いのか「そこまでGenAIが書かなかった」というだけである。顧客もマッピングするなら以下のように別の「トリプルマップとブランクノード3つ」を追加する。

```turtle
<#CustomerMasterMapping>
    a rr:TriplesMap ;
    rr:logicalTable [ rr:tableName "CUSTOMER_MASTER" ] ; 
    rr:subjectMap [
        rr:class ex:Customer ;
        rr:template "http://example.com/customer/{CUST_ID}" ;
    ] ;
    rr:predicateObjectMap [
        rr:predicate rdfs:label ;
        rr:objectMap [ rr:column "CUST_NAME" ]
    ] .

```

ちなみにこれを追加したものをGraph Explorerで表示すると、顧客と注文のブランクノードが同一視されたり、そもそもグラフが複雑過ぎて、二次元平面での可視化の限度を超えてしまうのであまりお勧めしない。

冒頭の図は「`rr:TripleMap`の三本足」や「ブランクノードと各リソースとの関係」を理解する上で参考にはなる。言い方を変えれば「教科書の挿絵」には向くが、実用上こういう見方をするか、というと「否」であろう。

### SQLエンジニアにどう説明するか？

そういうことで「R2RMLの視覚化はその理解には繋がらない」という一旦の結論を得たうえで、それではどうすれば他人に説明できる程度にコードの意味が理解できるか、を考えてみたい。ひとつのアプローチとしては「R2RMLの中のヒト」ではなく「SQLエンジニア目線」で捉える、というのが有りそうである。例えばこんな感じだ。

|#| R2RML構成要素 | 対応するSQL概念 | 例 |
|---| :--- | :--- | :--- |
|1| **Logical Table** | **データソース (FROM)** | (顧客)<br>`rr:logicalTable [ rr:tableName "CUSTOMER_MASTER" ]` <br>(注文)<br>`rr:logicalTable [ rr:tableName "ORDERS_TABLE" ] ;`|
|2| **Subject Map** | **Subject (主語) クラスのプライマリキー** | (顧客)<br>`rr:subjectMap [`<br>        `rr:class ex:Customer ;`<br>       `rr:template "http://example.com/customer/{CUST_ID}" ;`<br>    `] ;`<br>(注文)<br>`rr:subjectMap [`<br>        `rr:class ex:Order ; `<br>        `rr:template "http://example.com/order/{ORDER_ID}" ;`<br>    `] `;|
|3| **Predicate (Datatype)** | **属性名の特定** | (顧客)<br>`rr:predicate rdfs:label ;` |
|4| **Object Map (Column)** | **属性値の出力 (Literal)** |(顧客)<br>`rr:objectMap [rr:column "CUST_NAME"]` |
|5| **Predicate (Object)** | **代入先の特定** | (注文)<br>`rr:predicate ex:placedBy ;`|
|6| **Object Map (Template)** | **代入先属性名 (FK)** |(注文)<br> `rr:objectMap [rr:template "http://example.com/customer/{CUST_ID}" ;]` |

あまり分かりやすく整理できていないが、要するにひとつのsubject - 主語についてオントロジーと物理名リテラルを行を分けて書くことでマッピングしている、ということだろう。またRDFだけではSQLの外部キー参照を明示できないが、R2RMLは#5と#6で`ex:placedBy`の実体は`CUST_ID`、というかたちでこれを実現していることが分かる。

### R2RMLを書くのは誰か？

ひとつ良く解ったのが、R2RMLは「そもそもSQLの物理名称はラベル (記号) であってオントロジー (意味) ではない」という、厳格な原理原則の上に成り立っている、ということである。`rr:`語彙のobjectが全て二重引用で括られたリテラルであることからもそれは明らかだ。

「論物との橋渡し」は必ずどこかで生じるが、そこで姑息なやり方 (例えばAIなど) で翻訳を嚙ませる意味などない、という立場だ。オントロジーにSQLの物理名をリテラルでガシガシ書き加えれば良いじゃないか、というのはおっしゃる通り、それが一番シンプルかつ確実に決まっている。そしてその書き方も、w3Cさんが (もう10年以上前に!) ちゃんと考えてありますよ、というわけだ。

テーブルやカラムのラベルなど何でもアリアリである。パッケージなどのユーザ定義カラムの`OPTION_01`とかの名前でも、R2RMLのしかるべき位置に嵌めるだけだ (親切なヒトがいれば、ビューで名前をもう少し分かりやすく変えて見せてくれるかも知れない)。SQL文もこれで決定論的に生成できる。

しかし同様にその厳格な原理原則によれば、論理データモデルを物理からリバースする (このシリーズで最初にやったことである)、なんてのは「邪道」ということだ。これもおっしゃる通りで、`OPTION_01`の意味などGenAIが知る由もないのので当然である (インスタンス見れば「これは多分電話番号」くらいはやるのだろうが)。物理実装とは独立した論理データモデルを最初からRDFで書くのがやはり正道なのだ。

ここではたと気が付くのが「R2RMLを書くのは誰なのか？」というギモンである。なにせ論物との板挟みで、そもそも論理や物理の出来が悪いと一体どうなるのか、マッピング自体成り立つのか、など見当もつかない。もちろん今は答えは出ない。ただしこれは気に留めておかなければならない。ひょっとするとこれはチャンスなのかもしれないし、或いはこれが流行らないことには何らかの理由が有るのかもしれない。

さて、とりあえず誰が書くかはさておき、コードエディタ以外に「R2RMLを書く手段」をGenAIなりネットなりで掘っていくと「[Ontop](https://ontop-vkg.org/)なるものに行き当たった。なんでもProtégéのプラグインがあって、R2RMLの編集はもちろん、SPARQLを投げるとSQLに変換して値も返してくる、というものらしい。これは試さねばなるまい。

([Part20につづく](part20.md))

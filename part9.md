## ビジネスメタをオントロジーで書く - Part 9

### Fusekiを試す
Neo4jはオントロジーって何？という人々に、こんなものです、とビジュアルに示す手段としては手軽そうだが、データストアとしてはRDFは副業的な扱いであり、SPARQLも使えない。やはりオントロジーはRDFを本業とするデータストアに置きたい。

本番環境ならAmazon Neptune、となるのだろうが、秒で課金されては腰を据えて学習も出来ない。然るに過去回で名前だけ触れた[Apache Jena Fuseki](https://jena.apache.org/documentation/fuseki2/)を試してみると、これがめっぽうお手軽である。Javaが入っていてパスさえ通っていれば、[サイト](https://jena.apache.org/download/)から拾ってきたファイルを適当なところに置いて起動コマンドを打つだけで動く。SPARQLの練習にはもってこいである。

FusekiのUIでは、DatasetやGraph Nameといった目新しい用語をいくつか目にすることになる。これはNeo4jとの本質的な違いでもあり、早々に補足・整理しておく。

グラフデータ形式のRDFをW3C用語でRDF Datasetと呼ぶ。そして、ひとつのRDF Datasetは 「ひとつのDefault Graph」 と 「0個以上のNamed Graph」 ををもつ、ということになっている。

Graphが何で出来ているかというと、主語・述語・目的語という、いわゆるRDFトリプルと呼ばれる概念構造である。これらはURIという識別子 (`http://www.example.com/hoge`等) を持っているが、Named Graphとはこれらと同様に 「GraphそのものにURIが付いている」 という意味である。RDFトリプルにGraphも加えてQuad、と呼ぶこともあるようだ。

これとProtégéのようなオントロジー・エディタとの関係でいえば、ひとつのTTLファイルはひとつのGraph、ということになる。
複数のGraphからなるひとつのデータセットをSPARQLで横断的にクエリ出来たりするらしいが、まだそんなレベルではないので、使うGraphは差し当たりデフォルトだけでよい、というのが結論である。

FusekiはTTLファイルをインポート出来るし、またクエリ結果をturtle形式で返すSPARQLコマンドもあるので、TTLファイルとRDF Datasetとの間のinteroperabilityは確保されているようだ。とりあえずこの確認から始めることにする。

ここで要注意なのだが、FusekiのUIは結構適当で、TTLファイルのアップロード画面で 「空欄でデフォルトグラフに登録」 と書いてあるが、実はそうはならずエラーになる。さらに、URIを入れてアップロードするとエラーにはならないが、名前付きグラフではなくデフォルトグラフが登録される。もしこの先TTLファイルをNamed GraphとしてFusekiにアップロードしたい場合は、最初にSPARQLで空のNamed Graphを作って、そこにTTLファイルをアップロードする、という手順を踏む必要がある。

今回はNamed Graphは使わないので、若干モヤモヤするが、TTLファイルをFusekiにインポートする際は、エラー除けの為「だけ」に適当なGraph NameをURIで付けてDefault Graphを作ることにする。クエリ対象もDefault Graphだけ、つまりSPARQL文にGRAPH句は入らない、ということになる。

前置きが長くなったが、とりあえず[今のところの最終版](https://github.com/Yoshiyuki-iasa/northwind/blob/main/northwind_ontology_pt8.ttl)のTTLファイルをFusekiに読み込ませてみよう。すんなりと入ったので、すぐに`CONSTRUCT`句でTTL形式を出力してダウンロードしたものが[こちらのファイル](https://github.com/Yoshiyuki-iasa/northwind/blob/main/northwind_ontology_pt9.rdf)である。そのままちゃんとProtégéで開けるし、コードを見比べても行の並び順やインデントなどの見た目が違うが内容としては同一で、見易さという点ではむしろFusekiの出力のほうがキレイである。行数もほぼ同じ (元のTTLの方がコメント行などがあって少し多い) で、厳密にcompareしたわけではないが、「入りと出」で抜け漏れは無さそうである。Neo4jはこのあたりが不安だったのだが、やはり標準は有難いものである。

### 即席GraphRAG
最初にSPARQLの学習、などと書いたが、そもそもの目的はRDFで書いたメタデータをグラフデータベースで持てればデータが増えても安心だよね、というところの検証であった。

ここでポイントになるのが、GenAIによるメタデータの読み書きである。これまでのすべてのTTLファイルは直接的にはGemini CLIによって書かれている (インデントが雑で見にくいのもGemini CLIのせいである)。今度はこのTTLファイルの読み書き同様、GenAIはSPARQLを介してRDFトリプルストアを読み書き出来るか、というチャレンジである。

こんな思いつきを試したいとき、Gemini CLIとFusekiの組み合わせはまさにうってつけである。ローカル上のやり取りなのでネットワークとか認証とかを気にする必要がない。Gemini CLIに、FusekiのSPARQLエンドポイントに繋いでみて、と指示するだけである。見ているとGemini CLIでも一発目ですんなり繋がる、という訳でもないようだが、失敗するたびにエラーを解析しながら繋がるまで手を変え品を変えリトライを繰り返している。すぐキレたり心が折れたりする人間とは大違いである。

ほどなくしてGemini CLIが繋がりました、というので、何トリプルあるか、と尋ねると730です、との回答。念のためそのSPARQLを教えてもらって、Fusekiのブラウザで試すとちゃんと730と返ってくる (まあ当たり前ではあるが)。即席GraphRAGの一丁あがり、である。しかもRAGのソースを読むだけに限らず書くことも出来るだろう。次回からGenAIとRDFトリプルストアの組み合わせでどんなことが出来るのか、いろいろ試してみることにする。

(Part10につづく)
